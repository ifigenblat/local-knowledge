const mongoose = require('mongoose');
const crypto = require('crypto');

const cardSchema = new mongoose.Schema({
  cardId: {
    type: String,
    required: false, // Optional initially for migration, will be generated by pre-save hook
    unique: true,
    sparse: true, // Allow multiple null values during migration
    trim: true,
    uppercase: true,
    index: true
  },
  title: {
    type: String,
    required: true,
    trim: true,
    maxlength: 200
  },
  content: {
    type: String,
    required: true,
    maxlength: 10000
  },
  contentHash: {
    type: String,
    required: false, // Make it optional initially to avoid migration issues
    unique: false // Make it non-unique initially
  },
  type: {
    type: String,
    enum: ['concept', 'action', 'quote', 'checklist', 'mindmap'],
    default: 'concept'
  },
  category: {
    type: String,
    required: true,
    trim: true
  },
  tags: [{
    type: String,
    trim: true
  }],
  source: {
    type: String,
    trim: true
  },
  user: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'User',
    required: true
  },
  metadata: {
    difficulty: {
      type: Number,
      min: 1,
      max: 5,
      default: 3
    },
    estimatedTime: {
      type: Number, // in minutes
      default: 5
    },
    relatedCards: [{
      type: mongoose.Schema.Types.ObjectId,
      ref: 'Card'
    }],
    lastReviewed: {
      type: Date
    },
    reviewCount: {
      type: Number,
      default: 0
    },
    rating: {
      type: Number,
      min: 1,
      max: 5
    }
  },
  isPublic: {
    type: Boolean,
    default: false
  },
  generatedBy: {
    type: String,
    enum: ['rule-based', 'ai'],
    default: 'rule-based'
  },
  attachments: [{
    filename: String,
    originalName: String,
    mimetype: String,
    size: Number,
    path: String
  }],
  // Provenance and Evidence fields for trust tracking
  provenance: {
    source_file_id: {
      type: String,
      trim: true
    },
    source_path: {
      type: String,
      trim: true
    },
    file_hash: {
      type: String,
      trim: true
    },
    location: {
      // Can be page number, paragraph number, cell range, etc.
      type: String,
      trim: true
    },
    snippet: {
      // Original excerpt used to generate the card
      type: String,
      maxlength: 5000
    },
    model_name: {
      // AI model name if used for generation
      type: String,
      trim: true
    },
    prompt_version: {
      // Version of prompt used for generation
      type: String,
      trim: true,
      default: '1.0'
    },
    confidence_score: {
      // Confidence score (0-1) for the card generation
      type: Number,
      min: 0,
      max: 1
    }
  }
}, {
  timestamps: true
});

// Indexes for better search performance
cardSchema.index({ title: 'text', content: 'text', tags: 'text' });
cardSchema.index({ user: 1, category: 1 });
cardSchema.index({ type: 1, category: 1 });
cardSchema.index({ contentHash: 1, user: 1 }); // Index for duplicate detection
cardSchema.index({ cardId: 1 }); // Index for cardId lookups

// Virtual for formatted content
cardSchema.virtual('formattedContent').get(function() {
  return this.content.replace(/\n/g, '<br>');
});

// Method to generate a short, user-friendly card ID
cardSchema.statics.generateCardId = async function() {
  const chars = 'ABCDEFGHJKLMNPQRSTUVWXYZ23456789'; // Excludes 0, O, 1, I for clarity
  let cardId;
  let isUnique = false;
  let attempts = 0;
  const maxAttempts = 10;
  
  while (!isUnique && attempts < maxAttempts) {
    // Generate 6-character ID
    cardId = '';
    for (let i = 0; i < 6; i++) {
      cardId += chars.charAt(Math.floor(Math.random() * chars.length));
    }
    
    // Check if it's unique
    const existing = await this.findOne({ cardId });
    if (!existing) {
      isUnique = true;
    }
    attempts++;
  }
  
  if (!isUnique) {
    // Fallback: use timestamp-based ID if random generation fails
    const timestamp = Date.now().toString(36).toUpperCase().slice(-4);
    const random = Math.random().toString(36).toUpperCase().slice(-2);
    cardId = timestamp + random;
  }
  
  return cardId;
};

// Pre-save hook to generate cardId if not present
cardSchema.pre('save', async function(next) {
  if (!this.cardId) {
    this.cardId = await this.constructor.generateCardId();
  }
  next();
});

// Method to generate content hash
cardSchema.methods.generateContentHash = function() {
  const contentToHash = `${this.title.toLowerCase().trim()}-${this.content.toLowerCase().trim()}`;
  return crypto.createHash('sha256').update(contentToHash).digest('hex');
};

// Method to add related card
cardSchema.methods.addRelatedCard = function(cardId) {
  if (!this.metadata.relatedCards.includes(cardId)) {
    this.metadata.relatedCards.push(cardId);
    return this.save();
  }
  return Promise.resolve(this);
};

// Method to update review data
cardSchema.methods.updateReview = function() {
  this.metadata.lastReviewed = new Date();
  this.metadata.reviewCount += 1;
  return this.save();
};

// Static method to find cards by category
cardSchema.statics.findByCategory = function(category, userId) {
  return this.find({ category, user: userId }).sort({ createdAt: -1 });
};

// Static method to find cards by type
cardSchema.statics.findByType = function(type, userId) {
  return this.find({ type, user: userId }).sort({ createdAt: -1 });
};

// Static method to find duplicate cards
cardSchema.statics.findDuplicate = function(contentHash, userId) {
  if (!contentHash) return null;
  return this.findOne({ contentHash, user: userId });
};

// Static method to find card by cardId (for sharing)
cardSchema.statics.findByCardId = function(cardId) {
  return this.findOne({ cardId: cardId.toUpperCase() });
};

module.exports = mongoose.model('Card', cardSchema);
